Serenity BDD is easy to integrate with https://www.gradle.org/[Gradle], using the `serenity-gradle-plugin`. 
A simple example is shown here:

[source,groovy]
----
include::{srcdir}/junit-quick-start/build.gradle[tags=simple;advanced]
----
<1> Add the Serenity plugin to the Gradle build path
<2> Adds the aggregate and check tasks to the Gradle build
<3> The core Serenity BDD classes
<4> The Serenity BDD JUnit integration
<5> Ensure that the Gradle build does not stop at the first test failure, but goes on to generate the Serenity reports

First of all, add the Serenity BDD plugin entry to the Gradle build path in the `buildscript` section (1). This enables Gradle to find and apply the plugin to your project. You can check the latest version numbers on https://bintray.com/serenity/maven/[Bintray].

Next, you need to apply this plugin to your project (2) and add the Serenity BDD dependencies to your project.  You will typically add `core` (3) and another dependency that correpsonds to the testing library you are using (JUnit in this example: (4)).

The `serenity-gradle-plugin` adds below two tasks to your project:

aggregate::  Generates the Serenity aggregate reports from the JSON test results produced when you run the Serenity BDD tests.
checkOutcomes:: Check the test results in the output directory, and fail the build if there are errors or failures.

A typical use case is to run the tests and to always produce the aggregate report, no matter what the test results are. To do this in one line, you need to tell Gradle not to stop if the tests fail. You can do this by setting `gradle.startParameter.continueOnFailure` to `true`, and then running the following:

[source,bash]
----
gradle test aggregate
----

This will run the tests and generate an aggregate report in the `target/site/thucydides` directory.

Alternatively, configure Gradle as below by first removing the `gradle.startParameter.continueOnFailure = true` line.

Then add the following lines. As per the comments, this will configure the test task so that it will clear the reports first, 
always execute the Serenity tests, and will run the aggregate task regardless of whether a test fails or not.

If a test fails, the build will also fail, so you will receive appropriate notification, and if it's run on a CI server, the build will appear as broken.

This means you only need to execute `gradle test` to execute the tests and don't have to worry about previous runs cluttering up the results of this test execution.

[source,groovy]
----
test {
    // Ensure reports from a previous run are cleared up
    dependsOn clearReports
    // Ensure integration tests are always run. Will never report as 'UP-TO-DATE'
    outputs.upToDateWhen {false}
    // Ensure Serenity aggregation is run after, and if, integration tests are run
    finalizedBy aggregate
}
----